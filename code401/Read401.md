# What we will learn

- Pain vs. Suffering

- A beginner's guide to Big O Notation

The source of this summary [The first link](https://codefellows.github.io/code-401-python-guide/curriculum/class-01/notes/pain_suffering)

The source of this summary [The second link](https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation)
______________________________________

## Pain vs. Suffering

**The pain of growth by doing something new** 

1. You’ll lose sleep, you’ll forget to work out, and you’ll feel exhausted all while being filled with information day after day. 

2. You’ll be pushed physically, and while sitting in a chair and staring at your screen isn’t the most strenuous exercise in the world, the consecutive hours of it will take its toll.

3. You’ll have to research for hours on end, fleshing out the skeleton that we discuss in class, piling information on top of application so that you can reach your goals.


> All growth comes with some degree of pain, as it pulls you out of your comfort zone. The greater the growth, the greater the pain. But pain in the service of growth is a good thing, as long as that pain is what’s necessary to achieve the growth that you’re aiming for. And even better than that, this pain is only temporary. It’s what will launch you forward into the next phase of your life.

______________________________________

## A beginner's guide to Big O Notation

**Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. ... In computer science, big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows.**

<img src="https://cdn-media-1.freecodecamp.org/images/1*KfZYFUT2OKfjekJlCeYvuQ.jpeg" style="height: 300px; width:600px;"/>


1. O(1) describes an algorithm that will always execute in the same time (or space) regardless of the size of the input data set.

2. O(N) describes an algorithm whose performance will grow linearly and in direct proportion to the size of the input data set.

3. O(N²) represents an algorithm whose performance is directly proportional to the square of the size of the input data set.

4. O(2^N) denotes an algorithm whose growth doubles with each addition to the input data set.

